{"./":{"url":"./","title":"数据结构","keywords":"","body":"DataStructure Chapter1 "},"DataStructure/chapter1.html":{"url":"DataStructure/chapter1.html","title":"第一章","keywords":"","body":"DataStructure Chapter1 "},"POCC/chapter1.html":{"url":"POCC/chapter1.html","title":"计算机组成原理","keywords":"","body":"计算机组成原理 第一章 地址总线 32根地址总线，一共可以表示232个地址，地址以字节为单位，所以232个地址一共232B=222K=212M=4G "},"POCC/chapter2.html":{"url":"POCC/chapter2.html","title":"第二章","keywords":"","body":"第二章 "},"OS/chapter1.html":{"url":"OS/chapter1.html","title":"操作系统","keywords":"","body":"操作系统 第一章 页面置换算法 缺页：只要物理块中都没有当前页，就算缺页 先进先出置换算法（FIFO） 这种算法认为：最早调入主存的页面不再被使用的可能性最大。所以当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。 访问页面 1 2 3 4 2 1 5 2 1 物理块1 1∗ 1 1 4∗ 4 4 2∗ 物理块2 2∗ 2 2 1∗ 1 1 物理块3 3∗ 3 3 5∗ 5 是否缺页 √ √ √ √ √ √ √ FIFO 算法还会产生当所分配的物理块数增大，而缺页故障不减反增的情况。这是由 Belady于1969年发现，故称为Belady异常。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。 一个Belady实例如下： 当有三个物理块时，缺页率：9/12 访问页面 1 2 3 4 1 2 5 1 2 3 4 5 物理块1 1∗ 1 1 4∗ 4 4 5∗ 5 5 物理块2 2∗ 2 2 1∗ 1 1 3∗ 3 物理块3 3∗ 3 3 2∗ 2 2 4∗ 是否缺页 √ √ √ √ √ √ √ √ √ 当有4个物理块时，缺页率：10/12 访问页面 1 2 3 4 1 2 5 1 2 3 4 5 物理块1 1∗ 1 1 1 5∗ 5 5 5 4∗ 4 物理块2 2∗ 2 2 2 1∗ 1 1 1 5∗ 物理块3 3∗ 3 3 3 2∗ 2 2 2 物理块4 4∗ 4 4 4 3∗ 3 3 是否缺页 √ √ √ √ √ √ √ √ √ √ 即：缺页率高表现为：刚换出去的页面又要换回内存 极端表现如下： 访问页面 1 2 3 4 5 1 2 3 4 物理块1 1∗ 1 1 1 5∗ 5 5 5 4∗ 物理块2 2∗ 2 2 2 1∗ 1 1 1 物理块3 3∗ 3 3 3 2∗ 2 2 物理块4 4∗ 4 4 4 3∗ 3 最近最久未使用（LRU）算法 利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 访问页面 1 2 3 4 2 1 5 2 1 物理块1 1∗ 1 1 4∗ 4 5∗ 物理块2 2∗ 2 2 2 2 物理块3 3∗ 3 1∗ 1 是否缺页 √ √ √ √ √ √ 最佳置换算法（OPT 理想置换算法） 实现原理：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 访问页面 1 2 3 4 2 1 5 2 1 物理块1 1∗ 1 1 1 1 物理块2 2∗ 2 2 2 物理块3 3∗ 4∗ 5∗ 是否缺页 √ √ √ √ √ https://www.cnblogs.com/fkissx/p/4712959.html "},"Database/chapter1.html":{"url":"Database/chapter1.html","title":"数据库","keywords":"","body":"数据库 第一章 1.sql的执行顺序： 参考：https://wang286480403.iteye.com/blog/1899915 1. from 2. on 3. join 4. where 5. group by 6. WITH {CUBE | ROLLUP} avg,sum... 7. having 8. select 9. distinct 10. order by 1 (8)SELECT (9) DISTINCT (11) 2 (1) FROM 3 (3) JOIN 4 (2) ON 5 (4) WHERE 6 (5) GROUP BY 7 (6) WITH {CUBE | ROLLUP} 8 (7) HAVING 9 (10) ORDER BY "}}